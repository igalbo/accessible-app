import puppeteer, { Browser } from "puppeteer-core";
import chromium from "@sparticuz/chromium";
import { existsSync } from "fs";

export interface PDFGenerationOptions {
  scanId: string;
  baseUrl?: string;
}

/**
 * Launches Puppeteer browser with appropriate configuration for environment
 */
async function launchBrowser(): Promise<Browser> {
  const isProduction = process.env.NODE_ENV === "production";

  if (isProduction) {
    // Production (Vercel) - use @sparticuz/chromium
    console.log(
      "[PDF Generator] Launching browser in production mode with @sparticuz/chromium"
    );
    return await puppeteer.launch({
      args: chromium.args,
      defaultViewport: chromium.defaultViewport,
      executablePath: await chromium.executablePath(),
      headless: chromium.headless,
    });
  } else {
    // Local development - use system Chrome
    console.log("[PDF Generator] Launching browser in development mode");

    // Common Chrome/Chromium paths for different operating systems
    const possiblePaths = [
      "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome", // macOS
      "/usr/bin/google-chrome", // Linux
      "/usr/bin/chromium-browser", // Linux alternative
      "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe", // Windows
      "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe", // Windows 32-bit
    ];

    // Try to find Chrome installation
    let executablePath: string | undefined;
    for (const path of possiblePaths) {
      try {
        if (existsSync(path)) {
          executablePath = path;
          break;
        }
      } catch {
        continue;
      }
    }

    return await puppeteer.launch({
      headless: true,
      executablePath,
      args: ["--no-sandbox", "--disable-setuid-sandbox"],
    });
  }
}

export async function generatePDF({
  scanId,
  baseUrl = process.env.NEXT_PUBLIC_BASE_URL,
}: PDFGenerationOptions): Promise<Buffer> {
  if (!baseUrl) {
    throw new Error(
      "NEXT_PUBLIC_BASE_URL environment variable is required for PDF generation"
    );
  }

  const browser = await launchBrowser();

  try {
    const page = await browser.newPage();

    // Navigate to the report page
    const reportUrl = `${baseUrl}/reports/${scanId}`;
    console.log(`[PDF Generator] Navigating to: ${reportUrl}`);

    const response = await page.goto(reportUrl, {
      waitUntil: "networkidle0",
      timeout: 30000,
    });

    console.log(`[PDF Generator] Response status: ${response?.status()}`);

    // Wait for the content to be fully loaded
    await page.waitForSelector(".max-w-4xl", {
      timeout: 30000,
    });

    console.log(`[PDF Generator] Found content, generating PDF...`);

    // Wait a bit more for any dynamic content to load
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // Generate PDF with optimized settings
    const pdfBuffer = await page.pdf({
      format: "A4",
      margin: {
        top: "20mm",
        right: "15mm",
        bottom: "20mm",
        left: "15mm",
      },
      printBackground: true,
      preferCSSPageSize: false,
      displayHeaderFooter: true,
      headerTemplate: `
        <div style="font-size: 10px; color: #666; width: 100%; text-align: center; margin-top: 10px;">
          Accessibility Audit Report
        </div>
      `,
      footerTemplate: `
        <div style="font-size: 10px; color: #666; width: 100%; text-align: center; margin-bottom: 10px;">
          <span>Page <span class="pageNumber"></span> of <span class="totalPages"></span></span>
          <span style="margin-left: 20px;">Generated by Accessible Scanner</span>
        </div>
      `,
    });

    return Buffer.from(pdfBuffer);
  } catch (error) {
    console.error("PDF generation failed:", error);
    throw new Error(
      `Failed to generate PDF: ${
        error instanceof Error ? error.message : "Unknown error"
      }`
    );
  } finally {
    await browser.close();
  }
}

export function generatePDFFilename(url: string, scanId: string): string {
  // Clean up URL for filename
  const cleanUrl = url
    .replace(/^https?:\/\//, "")
    .replace(/[^a-zA-Z0-9.-]/g, "_")
    .substring(0, 50);

  const timestamp = new Date().toISOString().split("T")[0];
  return `accessibility-report-${cleanUrl}-${timestamp}-${scanId.substring(
    0,
    8
  )}.pdf`;
}
